<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>User Directory ‚Äî Neon Style</title>
    <style>
        /* üåå Page Base Setup */
        body {
            margin: 0;
            font-family: 'Segoe UI', Roboto, Arial, sans-serif;
            background: #111;
            /* dark background for neon contrast */
            color: #eee;
        }

        /* Centered main container */
        .container {
            max-width: 1200px;
            margin: 32px auto;
            padding: 16px;
            text-align: center;
        }

        /* Header */
        header h1 {
            margin: 0 0 8px;
            font-size: 2rem;
            color: #0ff;
            /* neon cyan */
        }

        /* üîç Search controls (input + buttons) */
        .controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        .controls input {
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #333;
            background: #000;
            color: #0ff;
            font-size: 1rem;
            min-width: 220px;
        }

        .controls button {
            padding: 10px 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            background: #0ff;
            color: #000;
            transition: all 0.2s ease;
        }

        .controls button:hover {
            background: #0cc;
        }

        .controls button.secondary {
            background: #333;
            color: #eee;
        }

        .controls button.secondary:hover {
            background: #444;
        }

        /* üé® Global color variables */
        :root {
            --color-bg-darkest: #000;
            --color-text-light: #aaa;
        }

        /* üß± Grid layout for user cards */
        .cards-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 40px;
        }

        /* ‚ú® Card styling */
        .card {
            position: relative;
            border: 1px solid var(--color-text-light);
            overflow: visible;
            background-color: #111;
            padding: 10px;
        }

        /* üåÄ Striped neon shadow using ::before pseudo-element */
        .card::before {
            content: "";
            position: absolute;
            bottom: 1px;
            left: 1px;
            transform: translate(-.5rem, .5rem);
            width: 100%;
            height: 100%;
            z-index: -1;
            transition: all .25s ease;
        }

        /* üé® Different colors per card using nth-child pattern */
        .card:nth-child(6n+1) {
            --card-color: #00d6e9;
        }

        .card:nth-child(6n+2) {
            --card-color: #15e3d9;
        }

        .card:nth-child(6n+3) {
            --card-color: #56edbf;
        }

        .card:nth-child(6n+4) {
            --card-color: #8cf5a2;
        }

        .card:nth-child(6n+5) {
            --card-color: #c2f985;
        }

        .card:nth-child(6n+6) {
            --card-color: #f9f871;
        }

        /* üî∫ Common border & color behavior */
        .card {
            color: var(--card-color);
            border-color: var(--card-color);
        }

        /* Striped diagonal shadow pattern for all cards */
        .card::before {
            background: repeating-linear-gradient(-45deg,
                    var(--card-color) 0,
                    var(--card-color) 4px,
                    transparent 0,
                    transparent 8px);
        }

        /* Hover / focus shadow movement */
        .card:hover::before,
        .card:focus-within::before {
            transform: translate(-1rem, 1rem);
        }

        /* üß© Inner card layout (text area) */
        .card__inner {
            background: var(--color-bg-darkest);
            padding: 1rem;
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 1;
            /* keep content above striped shadow */
        }

        /* üî† Text formatting inside cards */
        .card h2 {
            margin: 10px 0;
            font-size: 20px;
            color: #0ff;
        }

        .card p {
            margin: 6px 0;
            font-size: 0.95rem;
            color: #ddd;
        }

        .card a {
            color: #0ff;
            text-decoration: none;
        }

        .card a:hover {
            text-decoration: underline;
        }

        /* üè∑Ô∏è Small colored badges on top of each card */
        .badges {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-bottom: 8px;
        }

        .badge {
            padding: 4px 10px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: bold;
            color: #000;
        }

        /* Badge colors */
        .badge.cyan {
            background: #0ff;
        }

        .badge.green {
            background: #6f6;
        }

        .badge.yellow {
            background: #ff6;
        }

        .badge.pink {
            background: #f6c;
        }

        .badge.purple {
            background: #c6f;
        }

        .badge.red {
            background: #f66;
        }

        /* üìÑ Pagination buttons below cards */
        .pagination {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 25px 0;
        }

        .pagination button {
            padding: 8px 14px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            background: #0ff;
            color: #000;
            font-weight: 600;
            transition: all 0.2s;
        }

        .pagination button:hover {
            background: #0cc;
        }

        .pagination button:disabled {
            background: #333;
            color: #777;
            cursor: default;
        }

        /* üì¢ Status text (page info / loading info) */
        #status {
            margin-top: 10px;
            color: #aaa;
            font-size: 0.9rem;
            text-align: center;
        }
    </style>
</head>

<body>
    <div class="container">
        <!-- üè∑Ô∏è Header -->
        <header>
            <h1>Users Directory</h1>
        </header>

        <!-- üîç Search box and buttons -->
        <div class="controls">
            <input id="searchInput" type="search" placeholder="Search users..." />
            <button id="searchBtn">Search</button>
            <button id="clearBtn" class="secondary">Clear</button>
        </div>

        <!-- üß± Grid container where cards will appear -->
        <div id="cardGrid" class="cards-grid"></div>

        <!-- üìÑ Pagination controls -->
        <div class="pagination">
            <button id="prevBtn">Prev</button>
            <button id="nextBtn">Next</button>
        </div>

        <!-- ‚ÑπÔ∏è Page info -->
        <p id="status">Loading users‚Ä¶</p>
    </div>

    <script>
        /* ========= JS EXPLANATION =========
           This script fetches users from an API,
           displays them in neon cards with pagination
           and supports search + clear.
        ==================================== */

        let users = [];          // all users from API
        let filteredUsers = [];  // search results
        let currentPage = 1;     // current page number
        const perPage = 10;      // users per page

        const grid = document.getElementById('cardGrid');
        const statusEl = document.getElementById('status');
        const searchInput = document.getElementById('searchInput');

        /* Safely escape HTML to prevent XSS */
        function escapeHtml(str) {
            return str
                ? String(str).replace(/[&<>"]/g, s =>
                    ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;" }[s])
                )
                : '';
        }

        /* Combine address fields nicely */
        function formatAddress(addr) {
            if (!addr) return '';
            return [addr.street, addr.suite, addr.city].filter(Boolean).join(', ');
        }

        /* Random badge color from list */
        function getRandomBadge() {
            const classes = ['cyan', 'green', 'yellow', 'pink', 'purple', 'red'];
            return classes[Math.floor(Math.random() * classes.length)];
        }

        /* üßæ Renders cards for a given page */
        function renderPage(page) {
            grid.innerHTML = ''; // clear grid
            const start = (page - 1) * perPage;
            const end = start + perPage;
            const pageUsers = filteredUsers.slice(start, end);

            // No users case
            if (pageUsers.length === 0) {
                grid.innerHTML = '<p style="grid-column:1/-1;text-align:center;color:#999;">No users found.</p>';
                return;
            }

            // Create and append each card
            pageUsers.forEach(user => {
                const card = document.createElement('div');
                card.className = 'card';
                card.innerHTML = `
          <div class="badges">
            <span class="badge ${getRandomBadge()}">User</span>
            <span class="badge ${getRandomBadge()}">${escapeHtml(user.company?.name || "Company")}</span>
          </div>
          <h2>${escapeHtml(user.name)}</h2>
          <p><strong>Username:</strong> ${escapeHtml(user.username)}</p>
          <p><strong>Email:</strong> <a href="mailto:${escapeHtml(user.email)}">${escapeHtml(user.email)}</a></p>
          <p><strong>Address:</strong> ${escapeHtml(formatAddress(user.address))}</p>
          <p><strong>Phone:</strong> <a href="tel:${escapeHtml(user.phone)}">${escapeHtml(user.phone)}</a></p>
          <p><strong>Website:</strong> <a href="http://${escapeHtml(user.website)}" target="_blank">${escapeHtml(user.website)}</a></p>
        `;
                grid.appendChild(card);
            });

            // Update pagination state
            document.getElementById('prevBtn').disabled = (page === 1);
            document.getElementById('nextBtn').disabled = (end >= filteredUsers.length);

            // Status info (page count)
            statusEl.textContent = `Page ${page} of ${Math.ceil(filteredUsers.length / perPage)} ‚Äî Showing ${pageUsers.length} of ${filteredUsers.length} users.`;
        }

        /* üîç Search filter function */
        function searchUsers() {
            const q = searchInput.value.trim().toLowerCase();

            if (!q) filteredUsers = [...users];
            else {
                function match(v) { return v && String(v).toLowerCase().includes(q); }
                filteredUsers = users.filter(u =>
                    match(u.name) || match(u.username) || match(u.email) ||
                    match(formatAddress(u.address)) || match(u.phone) ||
                    match(u.website) || match(u.company?.name)
                );
            }

            currentPage = 1;
            renderPage(currentPage);
        }

        /* üåê Fetch users from JSONPlaceholder API */
        async function fetchUsers() {
            statusEl.textContent = 'Loading users‚Ä¶';
            try {
                const res = await fetch('https://jsonplaceholder.typicode.com/users');
                const data = await res.json();

                // duplicate dataset to show 100 users
                users = [];
                for (let i = 0; i < 100; i++) {
                    const base = data[i % data.length];
                    users.push({ ...base, id: i + 1, name: base.name + " " + (i + 1) });
                }

                filteredUsers = [...users];
                renderPage(currentPage);
            } catch (e) {
                console.error(e);
                statusEl.textContent = 'Failed to load users.';
            }
        }

        /* üñ±Ô∏è Button + input events */
        document.getElementById('searchBtn').addEventListener('click', searchUsers);
        searchInput.addEventListener('input', searchUsers);
        document.getElementById('clearBtn').addEventListener('click', () => {
            searchInput.value = '';
            searchUsers();
        });

        document.getElementById('prevBtn').addEventListener('click', () => {
            if (currentPage > 1) { currentPage--; renderPage(currentPage); }
        });

        document.getElementById('nextBtn').addEventListener('click', () => {
            if (currentPage < Math.ceil(filteredUsers.length / perPage)) {
                currentPage++;
                renderPage(currentPage);
            }
        });

        /* üöÄ Initialize app */
        fetchUsers();
    </script>
</body>

</html>